<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Range - V41 Neural Core</title>
    <style>
        /* ============================================================
           FOUNDATION STYLES
           ============================================================ */
        body { margin: 0; overflow: hidden; font-family: 'Inter', 'Segoe UI', monospace; background-color: #000; }
        canvas { display: block; }
        
        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #eeeeee; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; transition: opacity 0.8s ease; }
        .loader-title { font-size: 5rem; letter-spacing: 20px; font-weight: 200; color: #111; margin-bottom: 60px; text-transform: uppercase; }
        .loader-container { width: 80%; height: 30px; background: rgba(0,0,0,0.08); border-radius: 15px; overflow: hidden; }
        #loader-fill { width: 0%; height: 100%; background: #ff4b2b; transition: width 0.1s linear; }

        /* ============================================================
           SUB-MENU & PAIRING UI
           ============================================================ */
        #instructions {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            color: #111; background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px); z-index: 20; transition: opacity 0.4s ease;
        }

        /* The Pairing Box - Hidden initially */
        #neural-interface {
            display: none; opacity: 0;
            background: rgba(10, 10, 10, 0.98); padding: 30px; 
            width: 260px; border-left: 4px solid #ff4b2b; color: white;
            font-family: 'Courier New', monospace; font-size: 11px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5); border-radius: 4px;
            transition: opacity 0.5s ease;
        }

        .file-input-wrapper { position: relative; overflow: hidden; margin-top: 15px; width: 100%; }
        .file-input-wrapper input[type=file] { font-size: 100px; position: absolute; left: 0; top: 0; opacity: 0; cursor: pointer; }
        .btn-neural { background: #1a1a1a; border: 1px solid #333; color: #ff4b2b; padding: 12px; cursor: pointer; width: 100%; text-align: center; letter-spacing: 2px; font-weight: bold; text-transform: uppercase; }

        #boot-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: black; z-index: 90; pointer-events: none; opacity: 1; transition: opacity 5s ease-in-out; }

        .start-prompt { margin-top: 30px; font-weight: bold; color: #ff4b2b; cursor: pointer; padding: 12px 40px; letter-spacing: 5px; transition: 0.2s; border: 2px solid transparent; }
        .start-prompt:hover { border-color: #ff4b2b; background: rgba(255, 75, 43, 0.1); }

        /* HUD */
        #hud-container { position: absolute; bottom: 30px; left: 30px; display: flex; flex-direction: column; gap: 8px; z-index: 10; opacity: 0; transition: opacity 2s ease; }
        .stat-wrapper { background: rgba(0, 0, 0, 0.6); padding: 10px 20px; border-radius: 4px; border-left: 3px solid #6dd5ed; }
        .stat-label { color: white; font-size: 10px; text-transform: uppercase; letter-spacing: 2px; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>
    <div id="loading-screen">
        <div class="loader-title">LOADING</div>
        <div class="loader-container"><div id="loader-fill"></div></div>
    </div>

    <div id="boot-overlay"></div>
    
    <div id="instructions">
        <div id="main-manual" style="text-align: center;">
            <h1 style="letter-spacing: 15px; font-weight: 200;">MEGA DISTRICT</h1>
            <p>WASD — MOVE | V — PERSPECTIVE</p>
            <div class="start-prompt" id="start-btn">BEGIN NEURAL LINK</div>
        </div>
        
        <div id="neural-interface">
            <div style="color:#ff4b2b; font-weight:bold; margin-bottom:12px; letter-spacing:3px;">SYSTEM: OFFLINE</div>
            <div style="margin-bottom:10px; color:#aaa;">Upload robot core to initialize neural handshake.</div>
            <div class="file-input-wrapper">
                <button class="btn-neural">SELECT_CORE.GLB</button>
                <input type="file" id="robot-upload" accept=".glb">
            </div>
            <div id="uplink-id" style="margin-top:15px; text-align:center; color:#444;">AWAITING_SIGNAL</div>
        </div>
    </div>

    <div id="hud-container">
        <div class="stat-wrapper"><div class="stat-label">NEURAL LINK: ACTIVE</div></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let camera, scene, renderer, controls, cameraGroup;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, isGrounded = false;
        let robotVelocity = new THREE.Vector3(), robotMesh = null, headParts = [];
        let prevTime = performance.now();
        const robotHeight = 7.0;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            cameraGroup = new THREE.Group();
            cameraGroup.add(camera);
            scene.add(cameraGroup);

            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 2.0);
            scene.add(hemi);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new PointerLockControls(cameraGroup, document.body);

            const startBtn = document.getElementById('start-btn');
            const manual = document.getElementById('main-manual');
            const pairingBox = document.getElementById('neural-interface');
            const upload = document.getElementById('robot-upload');

            // 1. Transition to Sub-Menu
            startBtn.onclick = () => {
                manual.style.display = 'none';
                pairingBox.style.display = 'block';
                setTimeout(() => pairingBox.style.opacity = '1', 50);
            };

            // 2. Handle Pairing & 5s Boot
            upload.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const bootOverlay = document.getElementById('boot-overlay');
                const uplinkStatus = document.getElementById('uplink-id');
                
                uplinkStatus.innerText = "PAIRING...";
                uplinkStatus.style.color = "#ff4b2b";
                bootOverlay.style.opacity = "0"; // Start 5s fade to light

                // Audio Start
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const g = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 5);
                g.gain.linearRampToValueAtTime(0.1, ctx.currentTime + 4);
                osc.connect(g); g.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 5);

                // Load Robot
                const loader = new GLTFLoader();
                loader.load(URL.createObjectURL(file), (gltf) => {
                    robotMesh = gltf.scene;
                    const box = new THREE.Box3().setFromObject(robotMesh);
                    const scale = robotHeight / box.getSize(new THREE.Vector3()).y;
                    robotMesh.scale.set(scale, scale, scale);
                    
                    robotMesh.traverse(c => {
                        if (c.isMesh && c.name.toLowerCase().match(/head|eye|visor/)) {
                            headParts.push(c);
                            c.visible = false; // Hide for 1st person
                        }
                    });
                    scene.add(robotMesh);
                    controls.lock();

                    setTimeout(() => {
                        pairingBox.style.opacity = "0";
                        document.getElementById('hud-container').style.opacity = "1";
                        setTimeout(() => pairingBox.style.display = 'none', 500);
                    }, 5000);
                });
            };

            // World Creation
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshPhongMaterial({ color: 0x222222 }));
            floor.rotation.x = -Math.PI/2;
            scene.add(floor);

            document.addEventListener('keydown', (e) => {
                if(e.code === 'KeyW') moveForward = true;
                if(e.code === 'KeyS') moveBackward = true;
                if(e.code === 'KeyA') moveLeft = true;
                if(e.code === 'KeyD') moveRight = true;
            });
            document.addEventListener('keyup', (e) => {
                if(e.code === 'KeyW') moveForward = false;
                if(e.code === 'KeyS') moveBackward = false;
                if(e.code === 'KeyA') moveLeft = false;
                if(e.code === 'KeyD') moveRight = false;
            });

            // Start Loader
            let p = 0;
            const iv = setInterval(() => {
                p += 5; document.getElementById('loader-fill').style.width = p+'%';
                if(p>=100) { 
                    clearInterval(iv); 
                    document.getElementById('loading-screen').style.opacity = '0';
                    document.getElementById('instructions').style.display = 'flex';
                }
            }, 50);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = (performance.now() - prevTime) / 1000;
            prevTime = performance.now();

            if (controls.isLocked && robotMesh) {
                // Ground Physics
                const ray = new THREE.Raycaster(robotMesh.position.clone().add(new THREE.Vector3(0,1,0)), new THREE.Vector3(0,-1,0), 0, 1.1);
                const ground = ray.intersectObjects(scene.children);
                if (ground.length > 0) {
                    robotMesh.position.y = ground[0].point.y;
                    robotVelocity.y = 0;
                    isGrounded = true;
                } else {
                    robotVelocity.y -= 30 * delta;
                    robotMesh.position.y += robotVelocity.y * delta;
                    isGrounded = false;
                }

                // Move Robot
                const speed = 10;
                const camEuler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                const forward = new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(0, camEuler.y, 0));
                const right = new THREE.Vector3(1,0,0).applyEuler(new THREE.Euler(0, camEuler.y, 0));
                
                if(moveForward) robotMesh.position.add(forward.multiplyScalar(speed * delta));
                if(moveBackward) robotMesh.position.add(forward.multiplyScalar(-speed * delta));
                if(moveLeft) robotMesh.position.add(right.multiplyScalar(-speed * delta));
                if(moveRight) robotMesh.position.add(right.multiplyScalar(speed * delta));

                // Camera to Visor
                cameraGroup.position.copy(robotMesh.position);
                cameraGroup.position.y += (robotHeight * 0.85);
                const lookDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                cameraGroup.position.add(lookDir.multiplyScalar(0.4));
                
                robotMesh.rotation.y = camEuler.y + Math.PI;
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
